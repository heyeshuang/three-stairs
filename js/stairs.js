// Generated by CoffeeScript 1.7.1
var animate, camera, container, drawFloor, endPos, height, light, observer, renderer, scene, stackOfPos, stairDef, startPos, state, stepLength, stepV, width;

container = "canvasContainer";

stairDef = {
  w: 30,
  l: 100,
  h: 20
};

observer = new THREE.Vector3(0, 0, 100);

state = "rotate";

stackOfPos = [];

startPos = new THREE.Vector3(0, 0, 0);

endPos = new THREE.Vector3(0, 0, 0);

stepV = new THREE.Vector3(0, 0, 0);

stepLength = 0.002;

width = document.getElementById(container).clientWidth;

height = document.getElementById(container).clientHeight;

renderer = new THREE.WebGLRenderer({
  antialias: true
});

renderer.setSize(width, height);

document.getElementById(container).appendChild(renderer.domElement);

renderer.setClearColor(0x000000, 0.5);

camera = new THREE.PerspectiveCamera(75, width / height, 1, 10000);

camera.position.x = 100;

camera.position.y = 20;

camera.position.z = 80;

camera.up.x = 0;

camera.up.y = 0;

camera.up.z = 1;

camera.lookAt({
  x: 0,
  y: 0,
  z: 50
});

scene = new THREE.Scene();

light = new THREE.DirectionalLight(0xFF0000, 1.0, 0);

light.position.set(100, 100, 200);

scene.add(light);

drawFloor = function(orientation, startPos, numOfStairs, isUp) {
  var cube, i, _i;
  if (numOfStairs == null) {
    numOfStairs = 25;
  }
  if (isUp == null) {
    isUp = true;
  }
  for (i = _i = 0; 0 <= numOfStairs ? _i < numOfStairs : _i > numOfStairs; i = 0 <= numOfStairs ? ++_i : --_i) {
    if (orientation === "+x" || orientation === "-x") {
      cube = new THREE.Mesh(new THREE.CubeGeometry(stairDef.w, stairDef.l, stairDef.h), new THREE.MeshLambertMaterial({
        color: 0xff0000
      }));
    } else {
      cube = new THREE.Mesh(new THREE.CubeGeometry(stairDef.l, stairDef.w, stairDef.h), new THREE.MeshLambertMaterial({
        color: 0xff0000
      }));
    }
    cube.position.copy(startPos);
    switch (orientation) {
      case "+x":
        cube.position.x = startPos.x + stairDef.w * i;
        break;
      case "-x":
        cube.position.x = startPos.x - stairDef.w * i;
        break;
      case "+y":
        cube.position.y = startPos.y + stairDef.w * i;
        break;
      case "-y":
        cube.position.y = startPos.y - stairDef.w * i;
    }
    if (isUp) {
      cube.position.z = startPos.z + stairDef.h * i;
    } else {
      cube.position.z = startPos.z - stairDef.h * i;
    }
    scene.add(cube);
  }
  renderer.clear();
  renderer.render(scene, camera);
  return cube.position;
};

animate = function() {
  var newPos;
  requestAnimationFrame(animate);
  switch (state) {
    case "up":
      if (endPos.clone().add(observer).distanceTo(camera.position) < 1) {
        state = "rotate";
      } else {
        camera.position.add(stepV);
      }
      break;
    case "rotate":
      while (stackOfPos.length < 4) {
        if (stackOfPos.length < 1) {
          newPos = drawFloor("-x", new THREE.Vector3(0, 0, 0));
        } else {
          newPos = drawFloor("-x", stackOfPos.slice(-1)[0]);
        }
        stackOfPos.push(newPos);
      }
      startPos = endPos.clone();
      endPos = stackOfPos.shift();
      stepV = endPos.clone().add(observer).sub(camera.position).multiplyScalar(stepLength);
      state = "up";
  }
  return renderer.render(scene, camera);
};

animate();
