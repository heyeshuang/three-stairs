// Generated by CoffeeScript 1.7.1
var animate, camera, container, drawFloor, endPos, height, offset, renderer, scene, stackOfPos, stairDef, startPos, state, stepLength, stepV, width;

container = "canvasContainer";

stairDef = {
  w: 20,
  l: 80,
  h: 20
};

offset = new THREE.Vector3(-50, 10, 150);

state = "rotate";

stackOfPos = [];

startPos = new THREE.Vector3();

endPos = new THREE.Vector3();

stepV = new THREE.Vector3();

stepLength = 0.0015;

width = window.innerWidth;

height = window.innerHeight;

renderer = new THREE.WebGLRenderer({
  antialias: true
});

renderer.setSize(width, height);

document.getElementById(container).appendChild(renderer.domElement);

renderer.setClearColor(0x000000, 0.5);

camera = new THREE.PerspectiveCamera(75, width / height, 1, 10000);

camera.position.copy(offset);

camera.up.x = 0;

camera.up.y = 0;

camera.up.z = 1;

scene = new THREE.Scene();

scene.fog = new THREE.FogExp2(0x000000);

window.addEventListener('resize', onWindowResize, false);

drawFloor = function(orientation, startPos, numOfStairs, isUp) {
  var cube, i, l1, sphere, spotLight, _i;
  if (numOfStairs == null) {
    numOfStairs = 25;
  }
  if (isUp == null) {
    isUp = true;
  }
  for (i = _i = 0; 0 <= numOfStairs ? _i < numOfStairs : _i > numOfStairs; i = 0 <= numOfStairs ? ++_i : --_i) {
    if (orientation === "+x" || orientation === "-x") {
      cube = new THREE.Mesh(new THREE.CubeGeometry(stairDef.w, stairDef.l, stairDef.h), new THREE.MeshLambertMaterial({
        color: 0xff0000
      }));
    } else {
      cube = new THREE.Mesh(new THREE.CubeGeometry(stairDef.l, stairDef.w, stairDef.h), new THREE.MeshLambertMaterial({
        color: 0xff0000
      }));
    }
    cube.position.copy(startPos);
    switch (orientation) {
      case "+x":
        cube.position.x = startPos.x + stairDef.w * i;
        break;
      case "-x":
        cube.position.x = startPos.x - stairDef.w * i;
        break;
      case "+y":
        cube.position.y = startPos.y + stairDef.w * i;
        break;
      case "-y":
        cube.position.y = startPos.y - stairDef.w * i;
    }
    if (isUp) {
      cube.position.z = startPos.z + stairDef.h * i;
    } else {
      cube.position.z = startPos.z - stairDef.h * i;
    }
    scene.add(cube);
  }
  spotLight = new THREE.PointLight(0xffffff, 1.0, 400);
  spotLight.position.copy(new THREE.Vector3(0, 0, 500)).add(cube.position).lerp(startPos, 0.5);
  scene.add(spotLight);
  sphere = new THREE.SphereGeometry(0.5, 16, 8);
  l1 = new THREE.Mesh(sphere, new THREE.MeshBasicMaterial({
    color: 0x00ff00
  }));
  l1.position = spotLight.position;
  scene.add(l1);
  renderer.clear();
  renderer.render(scene, camera);
  return cube.position;
};

animate = function() {
  var isUp;
  requestAnimationFrame(animate);
  switch (state) {
    case "up":
      if (endPos.clone().add(offset).distanceTo(camera.position) < 1) {
        state = "rotate";
      } else {
        camera.position.add(stepV);
      }
      break;
    case "rotate":
      while (stackOfPos.length < 5) {
        stackOfPos.push(drawFloor("-x", stackOfPos.slice(-1)[0] || new THREE.Vector3(0, 0, 0), 25, isUp = true));
      }
      startPos = endPos.clone();
      endPos = stackOfPos.shift();
      stepV = endPos.clone().add(offset).sub(camera.position).multiplyScalar(stepLength);
      camera.lookAt(endPos.clone().add(new THREE.Vector3(0, 0, -400)));
      state = "up";
      console.log(endPos);
      console.log(spotLight.position.distanceTo(endPos));
      console.log("end");
  }
  return renderer.render(scene, camera);
};

animate();

//# sourceMappingURL=stairs.map
